import os
import shutil
from pathlib import Path

from ..ponder import Ponder
from ..format import logger
from .compiler import compile_operations


def compile_to_datapack(ponder: Ponder, version: bool = True, pos_offset: tuple = (0, 0, 0), ponder_name: str = "ponders",
                        output_dir: str = "."):
    """
    编译思索对象为Minecraft数据包
    :param ponder: 你的思索对象
    :param version: 是否为1.21+版本
    :param ponder_name: 你的思索名称
    :param pos_offset: 偏移坐标
    :param output_dir: 输出目录
    :return: 输出路径
    """
    logger.info(f"正在编译思索为数据包...")
    logger.debug(f"传入参数: version={version}, pos_offset={pos_offset}, ponder_name={ponder_name}, "
                 f"output_dir={output_dir}")

    output_file = Path(output_dir) / f"{ponder_name}.zip"

    # 检测输出的zip文件是否存在
    if output_file.exists():
        logger.warning(f"输出文件{output_file}已存在, 可能覆盖已有文件, 是否继续? (y/n)")
        if input().lower() != "y":
            logger.info(f"已取消编译.")
            return

    commands = compile_operations(ponder, pos_offset)

    # 生成数据包主结构
    datapack_dir = f"{output_dir}/{ponder_name}"
    if not os.path.exists(datapack_dir):
        os.makedirs(datapack_dir)

    # 生成pack.mcmeta
    with open(f"{datapack_dir}/pack.mcmeta", "w", encoding="utf-8") as f:
        # FIXME: 寻找正确的pack_format
        f.write(r'{"pack":{"pack_format":16,"supported_formats":[16,39],"description":"使用creepe_ponder生成的思索数据包"}}')

    # 生成用于存放函数的文件夹
    function_dir = f"{datapack_dir}/data/{ponder_name}/function" if version else \
        f"{datapack_dir}/data/{ponder_name}/functions"  # 傻逼mojang是这样, 乱改数据包结构
    os.makedirs(function_dir)

    functions = {}  # 存放函数的列表
    # 整理每个时刻工作的指令
    for command in commands:
        time, command_str = command
        if time in functions:
            functions[time].append(command_str)
        else:
            functions[time] = [command_str]

    # 将指令写入函数文件
    for time, command_list in functions.items():
        function_path = f"{function_dir}/{time}.mcfunction"

        with open(function_path, "w", encoding="utf-8") as f:
            text = "# Generated by creepe_ponder 本函数文件由creepe_ponder生成\n"

            for command in command_list:
                text += str(command) + "\n"
            f.write(text)

    # 主函数文件
    main_function_path = f"{function_dir}/main.mcfunction"
    # 使用/schedule指令让函数文件按顺序执行
    with open(main_function_path, "w", encoding="utf-8") as f:
        text = "# Generated by creepe_ponder 本函数文件由creepe_ponder生成\n"

        for time in functions.keys():
            text += f"schedule function {ponder_name}:{time} {time * 2 + 1} append\n"  # rt转为gt, 并增加一个偏移量

        f.write(text)

    # 打包数据包
    shutil.make_archive(f"{output_dir}/{ponder_name}", "zip", datapack_dir)

    # 删除临时文件
    shutil.rmtree(datapack_dir)

    logger.info(f"编译完成, 共在{len(functions.keys())}个时刻输出{len(commands)}条指令, "
                f"总动画长度: {max(functions.keys()) / 20}秒, 输出路径: {output_dir}/{ponder_name}.zip")
